"""PoC Verification Module - Code-based vulnerability validation.

This module executes PoC requests generated by LLM and validates results.
The LLM generates strategies; code makes final determinations.
"""

from __future__ import annotations

import asyncio
import logging
import re
from typing import Any
from dataclasses import dataclass

import httpx

logger = logging.getLogger(__name__)


@dataclass
class PoCRequest:
    """A PoC request generated by LLM for validation."""
    
    method: str
    url: str
    parameters: dict[str, Any] | None = None
    headers: dict[str, str] | None = None
    body: str | None = None
    expected_indicators: list[str] | None = None  # What to look for in response
    vulnerability_type: str = "unknown"


@dataclass
class ValidationResult:
    """Result of PoC validation."""
    
    is_vulnerable: bool
    confidence: str  # high, medium, low
    evidence: list[str]
    response_data: dict[str, Any]
    validation_method: str  # How it was validated


class PoCValidator:
    """Validates vulnerabilities by executing PoC requests.
    
    This is CODE-DRIVEN validation. LLM provides PoC strategies,
    but this validator makes the final determination.
    """
    
    def __init__(self, timeout: int = 10):
        self.timeout = timeout
    
    async def validate_poc(self, poc: PoCRequest, baseline_response: dict[str, Any] | None = None) -> ValidationResult:
        """Execute PoC and validate if vulnerability exists.
        
        Args:
            poc: PoC request to execute
            baseline_response: Optional baseline response for comparison
            
        Returns:
            ValidationResult with is_vulnerable determination
        """
        logger.info(f"Validating PoC: {poc.vulnerability_type} on {poc.url}")
        
        # Execute PoC request
        poc_response = await self._execute_poc(poc)
        
        if poc_response.get("error"):
            return ValidationResult(
                is_vulnerable=False,
                confidence="low",
                evidence=[f"PoC execution failed: {poc_response['error']}"],
                response_data=poc_response,
                validation_method="execution_failed"
            )
        
        # Validate based on vulnerability type
        validation_func = self._get_validation_function(poc.vulnerability_type)
        return validation_func(poc, poc_response, baseline_response)
    
    async def _execute_poc(self, poc: PoCRequest) -> dict[str, Any]:
        """Execute the PoC HTTP request."""
        try:
            async with httpx.AsyncClient(verify=False, timeout=self.timeout, follow_redirects=True) as client:
                
                headers = poc.headers or {}
                
                if poc.method.upper() == "GET":
                    response = await client.get(poc.url, params=poc.parameters, headers=headers)
                elif poc.method.upper() == "POST":
                    if poc.body:
                        response = await client.post(poc.url, content=poc.body, headers=headers)
                    else:
                        response = await client.post(poc.url, data=poc.parameters, headers=headers)
                else:
                    response = await client.request(
                        poc.method, poc.url, params=poc.parameters, headers=headers
                    )
                
                return {
                    "status_code": response.status_code,
                    "headers": dict(response.headers),
                    "body": response.text,
                    "url": str(response.url)
                }
                
        except Exception as e:
            logger.error(f"PoC execution error: {e}")
            return {"error": str(e)}
    
    def _get_validation_function(self, vuln_type: str):
        """Get appropriate validation function for vulnerability type."""
        validators = {
            "xss": self._validate_xss,
            "sql_injection": self._validate_sqli,
            "ssrf": self._validate_ssrf,
            "xxe": self._validate_xxe,
            "rce": self._validate_rce,
            "idor": self._validate_idor,
        }
        
        # Normalize vuln type
        vuln_type_lower = vuln_type.lower().replace(" ", "_")
        
        for key in validators:
            if key in vuln_type_lower:
                return validators[key]
        
        # Default generic validation
        return self._validate_generic
    
    def _validate_xss(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate XSS vulnerability."""
        body = response.get("body", "")
        evidence = []
        
        # Look for reflected payload
        if poc.expected_indicators:
            for indicator in poc.expected_indicators:
                if indicator in body:
                    evidence.append(f"Payload reflected: {indicator}")
        
        # Check for script execution context
        dangerous_contexts = [
            r'<script[^>]*>.*?' + re.escape(str(poc.parameters.get("test", ""))) if poc.parameters else "",
            r'on\w+\s*=\s*["\'].*?' + re.escape(str(poc.parameters.get("test", ""))) if poc.parameters else "",
        ]
        
        for pattern in dangerous_contexts:
            if pattern and re.search(pattern, body, re.IGNORECASE):
                evidence.append(f"Dangerous context detected: {pattern}")
        
        is_vulnerable = len(evidence) > 0
        confidence = "high" if len(evidence) >= 2 else "medium" if evidence else "low"
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence=confidence,
            evidence=evidence if evidence else ["No XSS indicators found"],
            response_data=response,
            validation_method="xss_pattern_matching"
        )
    
    def _validate_sqli(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate SQL injection vulnerability."""
        body = response.get("body", "")
        status = response.get("status_code", 0)
        evidence = []
        
        # SQL error patterns
        sql_errors = [
            r"sql\s+syntax",
            r"mysql",
            r"postgresql",
            r"ora-\d+",
            r"microsoft\s+ole\s+db",
            r"odbc\s+driver",
            r"sqlite",
            r"syntax\s+error",
            r"unclosed\s+quotation",
            r"you have an error in your sql",
        ]
        
        for pattern in sql_errors:
            if re.search(pattern, body, re.IGNORECASE):
                evidence.append(f"SQL error pattern: {pattern}")
        
        # Time-based detection (if baseline provided)
        if baseline and "execution_time" in response and "execution_time" in baseline:
            time_diff = response["execution_time"] - baseline["execution_time"]
            if time_diff > 5:  # 5 second delay
                evidence.append(f"Time-based SQLi suspected: {time_diff}s delay")
        
        # Boolean-based detection
        if baseline and baseline.get("body"):
            if len(body) != len(baseline["body"]) and abs(len(body) - len(baseline["body"])) > 100:
                evidence.append(f"Response length differs significantly from baseline")
        
        is_vulnerable = len(evidence) > 0
        confidence = "high" if any("error" in e.lower() for e in evidence) else "medium"
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence=confidence,
            evidence=evidence if evidence else ["No SQL injection indicators found"],
            response_data=response,
            validation_method="sqli_error_based"
        )
    
    def _validate_ssrf(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate SSRF vulnerability."""
        body = response.get("body", "")
        evidence = []
        
        # Check for internal IP addresses in response
        internal_ip_patterns = [
            r"127\.0\.0\.\d+",
            r"localhost",
            r"169\.254\.\d+\.\d+",
            r"10\.\d+\.\d+\.\d+",
            r"172\.(1[6-9]|2\d|3[01])\.\d+\.\d+",
            r"192\.168\.\d+\.\d+",
        ]
        
        for pattern in internal_ip_patterns:
            if re.search(pattern, body):
                evidence.append(f"Internal IP pattern detected: {pattern}")
        
        # Check for DNS rebinding or metadata endpoints
        metadata_indicators = ["metadata", "instance-data", "user-data"]
        for indicator in metadata_indicators:
            if indicator in body.lower():
                evidence.append(f"Metadata endpoint indicator: {indicator}")
        
        is_vulnerable = len(evidence) > 0
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence="high" if evidence else "low",
            evidence=evidence if evidence else ["No SSRF indicators found"],
            response_data=response,
            validation_method="ssrf_pattern_detection"
        )
    
    def _validate_xxe(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate XXE vulnerability."""
        body = response.get("body", "")
        evidence = []
        
        # Look for file contents or entity expansion
        if poc.expected_indicators:
            for indicator in poc.expected_indicators:
                if indicator in body:
                    evidence.append(f"Expected indicator found: {indicator}")
        
        # Look for common file indicators
        file_indicators = ["/etc/passwd", "root:", "bin/bash", "DOCTYPE"]
        for indicator in file_indicators:
            if indicator in body:
                evidence.append(f"File content indicator: {indicator}")
        
        is_vulnerable = len(evidence) > 0
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence="high" if evidence else "low",
            evidence=evidence if evidence else ["No XXE indicators found"],
            response_data=response,
            validation_method="xxe_content_detection"
        )
    
    def _validate_rce(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate RCE vulnerability."""
        body = response.get("body", "")
        evidence = []
        
        # Look for command execution indicators
        if poc.expected_indicators:
            for indicator in poc.expected_indicators:
                if indicator in body:
                    evidence.append(f"Command output detected: {indicator}")
        
        # Common command output patterns
        command_patterns = ["uid=", "gid=", "groups=", "root", "bin/sh", "bin/bash"]
        for pattern in command_patterns:
            if pattern in body:
                evidence.append(f"Command execution pattern: {pattern}")
        
        is_vulnerable = len(evidence) > 0
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence="high" if evidence else "low",
            evidence=evidence if evidence else ["No RCE indicators found"],
            response_data=response,
            validation_method="rce_output_detection"
        )
    
    def _validate_idor(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Validate IDOR vulnerability."""
        status = response.get("status_code", 0)
        body = response.get("body", "")
        evidence = []
        
        # Successful access to unauthorized resource
        if status == 200:
            evidence.append("Successful access with modified ID")
            
            # Check for user-specific data patterns
            sensitive_patterns = ["email", "phone", "address", "password", "token"]
            for pattern in sensitive_patterns:
                if pattern in body.lower():
                    evidence.append(f"Sensitive data field found: {pattern}")
        
        # Compare with baseline if available
        if baseline and baseline.get("status_code") == 403 and status == 200:
            evidence.append("Bypassed authorization check")
        
        is_vulnerable = len(evidence) > 0
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence="medium" if evidence else "low",
            evidence=evidence if evidence else ["No IDOR indicators found"],
            response_data=response,
            validation_method="idor_authorization_bypass"
        )
    
    def _validate_generic(self, poc: PoCRequest, response: dict[str, Any], baseline: dict[str, Any] | None) -> ValidationResult:
        """Generic validation for unknown vulnerability types."""
        evidence = []
        
        # Check for expected indicators if provided
        if poc.expected_indicators:
            body = response.get("body", "")
            for indicator in poc.expected_indicators:
                if indicator in body:
                    evidence.append(f"Expected indicator found: {indicator}")
        
        # Check for error status codes
        status = response.get("status_code", 0)
        if status >= 500:
            evidence.append(f"Server error: {status}")
        
        is_vulnerable = len(evidence) > 0
        
        return ValidationResult(
            is_vulnerable=is_vulnerable,
            confidence="low",
            evidence=evidence if evidence else ["Generic validation - no clear indicators"],
            response_data=response,
            validation_method="generic_validation"
        )
